module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/http [external] (http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[externals]/punycode [external] (punycode, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("punycode", () => require("punycode"));

module.exports = mod;
}),
"[externals]/https [external] (https, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}),
"[externals]/zlib [external] (zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}),
"[externals]/util [external] (util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}),
"[externals]/node:fs [external] (node:fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:fs", () => require("node:fs"));

module.exports = mod;
}),
"[externals]/node:stream [external] (node:stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:stream", () => require("node:stream"));

module.exports = mod;
}),
"[externals]/node:stream/web [external] (node:stream/web, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:stream/web", () => require("node:stream/web"));

module.exports = mod;
}),
"[project]/lib/intent-parser.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// ============================================
// INTENT PARSER - LLM/Retrieval-Augmented
// Maps user goals to component taxonomy
// ============================================
__turbopack_context__.s([
    "IntentParser",
    ()=>IntentParser,
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anthropic$2d$ai$2f$sdk$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@anthropic-ai/sdk/index.mjs [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@supabase/supabase-js/dist/module/index.js [app-route] (ecmascript) <locals>");
;
;
const anthropic = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$anthropic$2d$ai$2f$sdk$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"]({
    apiKey: process.env.ANTHROPIC_API_KEY
});
const supabase = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createClient"])(("TURBOPACK compile-time value", "https://kntjsvnhwkneqszdhwtc.supabase.co"), process.env.SUPABASE_SERVICE_ROLE_KEY);
class IntentParser {
    /**
   * Parse user intent into structured components
   * @param {string} userIntent - User's goal (e.g., "build a home theater")
   * @param {object} userProfile - Optional user preferences and history
   * @returns {object} Parsed intent with components and requirements
   */ async parseIntent(userIntent, userProfile = null) {
        // Step 1: Retrieve relevant templates from knowledge base
        const templates = await this.retrieveTemplates(userIntent);
        // Step 2: Get user preferences if available
        const preferences = userProfile ? await this.getUserPreferences(userProfile.userId) : null;
        // Step 3: Use LLM to decompose intent with RAG context
        const parsedIntent = await this.llmDecompose(userIntent, templates, preferences);
        // Step 4: Map to product taxonomy
        const mappedComponents = await this.mapToTaxonomy(parsedIntent);
        return {
            originalIntent: userIntent,
            projectType: parsedIntent.projectType,
            category: parsedIntent.category,
            components: mappedComponents,
            requirements: parsedIntent.requirements,
            preferences: parsedIntent.preferences,
            estimatedBudget: parsedIntent.estimatedBudget,
            complexity: parsedIntent.complexity,
            parsedAt: new Date().toISOString()
        };
    }
    /**
   * Retrieve relevant templates from knowledge base
   */ async retrieveTemplates(userIntent) {
        // Use keyword matching to find relevant templates
        const { data: templates, error } = await supabase.from('project_templates').select('*').limit(3);
        if (error) {
            console.error('Error retrieving templates:', error);
            return [];
        }
        return templates || [];
    }
    /**
   * Get user preferences from profile store
   */ async getUserPreferences(userId) {
        const { data: preferences, error } = await supabase.from('user_preferences').select('*').eq('user_id', userId);
        if (error) {
            console.error('Error retrieving preferences:', error);
            return null;
        }
        // Convert to key-value object
        const prefs = {};
        preferences?.forEach((pref)=>{
            prefs[pref.preference_key] = pref.preference_value;
        });
        return prefs;
    }
    /**
   * LLM-powered intent decomposition with RAG
   */ async llmDecompose(userIntent, templates, preferences) {
        const templateContext = templates.length > 0 ? `\n\nRelevant templates:\n${JSON.stringify(templates, null, 2)}` : '';
        const preferenceContext = preferences ? `\n\nUser preferences:\n${JSON.stringify(preferences, null, 2)}` : '';
        const prompt = `You are an expert at decomposing complex purchasing goals into structured requirements.

User Intent: "${userIntent}"
${templateContext}${preferenceContext}

Analyze this intent and return a structured JSON response with:
1. projectType: A clear name for this type of project (e.g., "home_theater", "gaming_pc")
2. category: High-level category (e.g., "home_entertainment", "computing", "diy")
3. requirements: Detailed technical and functional requirements
4. preferences: Inferred user preferences (budget sensitivity, brand preferences, quality vs price)
5. estimatedBudget: Estimated budget range {min, max}
6. complexity: Project complexity ("beginner", "intermediate", "advanced")
7. components: List of needed components with:
   - componentName: What is needed
   - category: Product category
   - priority: "essential", "recommended", or "optional"
   - quantity: How many needed
   - specifications: Any technical specs mentioned or implied
   - reasoning: Why this component is needed

Be specific about technical requirements like:
- For home theater: HDMI versions, audio formats, speaker impedance, wattage
- For gaming: GPU requirements, monitor refresh rates, resolution
- For DIY: material specifications, tool requirements

Return ONLY valid JSON, no markdown formatting.`;
        const message = await anthropic.messages.create({
            model: 'claude-sonnet-4-5-20250929',
            max_tokens: 4000,
            messages: [
                {
                    role: 'user',
                    content: prompt
                }
            ]
        });
        const responseText = message.content[0].text;
        try {
            // Remove markdown code blocks if present
            const jsonText = responseText.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
            return JSON.parse(jsonText);
        } catch (error) {
            console.error('Error parsing LLM response:', error);
            throw new Error('Failed to parse intent');
        }
    }
    /**
   * Map parsed components to product taxonomy/categories
   */ async mapToTaxonomy(parsedIntent) {
        // Get product categories from database
        const { data: categories, error } = await supabase.from('product_categories').select('*');
        if (error) {
            console.error('Error retrieving categories:', error);
            return parsedIntent.components;
        }
        // Map each component to closest category match
        return parsedIntent.components.map((component)=>{
            // Find best matching category
            const matchedCategory = categories?.find((cat)=>cat.name.toLowerCase().includes(component.category?.toLowerCase()) || component.category?.toLowerCase().includes(cat.name.toLowerCase()));
            return {
                ...component,
                categoryId: matchedCategory?.id || null,
                requiredSpecs: matchedCategory?.required_specs || {},
                taxonomyMapped: !!matchedCategory
            };
        });
    }
    /**
   * Validate parsed intent for completeness
   */ validateIntent(parsedIntent) {
        const errors = [];
        if (!parsedIntent.projectType) {
            errors.push('Missing project type');
        }
        if (!parsedIntent.components || parsedIntent.components.length === 0) {
            errors.push('No components identified');
        }
        const essentialComponents = parsedIntent.components?.filter((c)=>c.priority === 'essential');
        if (essentialComponents?.length === 0) {
            errors.push('No essential components identified');
        }
        return {
            isValid: errors.length === 0,
            errors
        };
    }
}
const __TURBOPACK__default__export__ = IntentParser;
}),
"[project]/app/api/parse-intent/route.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// ============================================
// API ROUTE: /api/parse-intent
// Intent Parser - Decomposes user goals
// ============================================
__turbopack_context__.s([
    "POST",
    ()=>POST,
    "maxDuration",
    ()=>maxDuration,
    "runtime",
    ()=>runtime
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$intent$2d$parser$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/intent-parser.js [app-route] (ecmascript)");
;
;
async function POST(request) {
    try {
        const { userIntent, userId } = await request.json();
        if (!userIntent || typeof userIntent !== 'string') {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'User intent is required'
            }, {
                status: 400
            });
        }
        // Initialize Intent Parser
        const parser = new __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$intent$2d$parser$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]();
        // Parse the intent
        const parsedIntent = await parser.parseIntent(userIntent, userId ? {
            userId
        } : null);
        // Validate the parsed intent
        const validation = parser.validateIntent(parsedIntent);
        if (!validation.isValid) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                success: false,
                parsedIntent,
                validation
            }, {
                status: 200
            });
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: true,
            parsedIntent,
            validation
        });
    } catch (error) {
        console.error('Intent parsing error:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Failed to parse intent',
            details: error.message
        }, {
            status: 500
        });
    }
}
const runtime = 'nodejs';
const maxDuration = 30;
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__54859e7d._.js.map