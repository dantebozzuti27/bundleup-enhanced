{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 106, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/dbozz/bundleup-enhanced/lib/intent-parser.js"],"sourcesContent":["// ============================================\n// INTENT PARSER - LLM/Retrieval-Augmented\n// Maps user goals to component taxonomy\n// ============================================\n\nimport Anthropic from '@anthropic-ai/sdk';\nimport { createClient } from '@supabase/supabase-js';\n\nconst anthropic = new Anthropic({\n  apiKey: process.env.ANTHROPIC_API_KEY,\n});\n\nconst supabase = createClient(\n  process.env.NEXT_PUBLIC_SUPABASE_URL,\n  process.env.SUPABASE_SERVICE_ROLE_KEY\n);\n\n/**\n * Intent Parser - Analyzes user input and decomposes into structured requirements\n */\nexport class IntentParser {\n  \n  /**\n   * Parse user intent into structured components\n   * @param {string} userIntent - User's goal (e.g., \"build a home theater\")\n   * @param {object} userProfile - Optional user preferences and history\n   * @returns {object} Parsed intent with components and requirements\n   */\n  async parseIntent(userIntent, userProfile = null) {\n    \n    // Step 1: Retrieve relevant templates from knowledge base\n    const templates = await this.retrieveTemplates(userIntent);\n    \n    // Step 2: Get user preferences if available\n    const preferences = userProfile ? await this.getUserPreferences(userProfile.userId) : null;\n    \n    // Step 3: Use LLM to decompose intent with RAG context\n    const parsedIntent = await this.llmDecompose(userIntent, templates, preferences);\n    \n    // Step 4: Map to product taxonomy\n    const mappedComponents = await this.mapToTaxonomy(parsedIntent);\n    \n    return {\n      originalIntent: userIntent,\n      projectType: parsedIntent.projectType,\n      category: parsedIntent.category,\n      components: mappedComponents,\n      requirements: parsedIntent.requirements,\n      preferences: parsedIntent.preferences,\n      estimatedBudget: parsedIntent.estimatedBudget,\n      complexity: parsedIntent.complexity,\n      parsedAt: new Date().toISOString()\n    };\n  }\n  \n  /**\n   * Retrieve relevant templates from knowledge base\n   */\n  async retrieveTemplates(userIntent) {\n    // Use keyword matching to find relevant templates\n    const { data: templates, error } = await supabase\n      .from('project_templates')\n      .select('*')\n      .limit(3);\n    \n    if (error) {\n      console.error('Error retrieving templates:', error);\n      return [];\n    }\n    \n    return templates || [];\n  }\n  \n  /**\n   * Get user preferences from profile store\n   */\n  async getUserPreferences(userId) {\n    const { data: preferences, error } = await supabase\n      .from('user_preferences')\n      .select('*')\n      .eq('user_id', userId);\n    \n    if (error) {\n      console.error('Error retrieving preferences:', error);\n      return null;\n    }\n    \n    // Convert to key-value object\n    const prefs = {};\n    preferences?.forEach(pref => {\n      prefs[pref.preference_key] = pref.preference_value;\n    });\n    \n    return prefs;\n  }\n  \n  /**\n   * LLM-powered intent decomposition with RAG\n   */\n  async llmDecompose(userIntent, templates, preferences) {\n    \n    const templateContext = templates.length > 0 \n      ? `\\n\\nRelevant templates:\\n${JSON.stringify(templates, null, 2)}`\n      : '';\n    \n    const preferenceContext = preferences \n      ? `\\n\\nUser preferences:\\n${JSON.stringify(preferences, null, 2)}`\n      : '';\n    \n    const prompt = `You are an expert at decomposing complex purchasing goals into structured requirements.\n\nUser Intent: \"${userIntent}\"\n${templateContext}${preferenceContext}\n\nAnalyze this intent and return a structured JSON response with:\n1. projectType: A clear name for this type of project (e.g., \"home_theater\", \"gaming_pc\")\n2. category: High-level category (e.g., \"home_entertainment\", \"computing\", \"diy\")\n3. requirements: Detailed technical and functional requirements\n4. preferences: Inferred user preferences (budget sensitivity, brand preferences, quality vs price)\n5. estimatedBudget: Estimated budget range {min, max}\n6. complexity: Project complexity (\"beginner\", \"intermediate\", \"advanced\")\n7. components: List of needed components with:\n   - componentName: What is needed\n   - category: Product category\n   - priority: \"essential\", \"recommended\", or \"optional\"\n   - quantity: How many needed\n   - specifications: Any technical specs mentioned or implied\n   - reasoning: Why this component is needed\n\nBe specific about technical requirements like:\n- For home theater: HDMI versions, audio formats, speaker impedance, wattage\n- For gaming: GPU requirements, monitor refresh rates, resolution\n- For DIY: material specifications, tool requirements\n\nReturn ONLY valid JSON, no markdown formatting.`;\n\n    const message = await anthropic.messages.create({\n      model: 'claude-sonnet-4-5-20250929',\n      max_tokens: 4000,\n      messages: [{\n        role: 'user',\n        content: prompt\n      }]\n    });\n    \n    const responseText = message.content[0].text;\n    \n    try {\n      // Remove markdown code blocks if present\n      const jsonText = responseText.replace(/```json\\n?/g, '').replace(/```\\n?/g, '').trim();\n      return JSON.parse(jsonText);\n    } catch (error) {\n      console.error('Error parsing LLM response:', error);\n      throw new Error('Failed to parse intent');\n    }\n  }\n  \n  /**\n   * Map parsed components to product taxonomy/categories\n   */\n  async mapToTaxonomy(parsedIntent) {\n    // Get product categories from database\n    const { data: categories, error } = await supabase\n      .from('product_categories')\n      .select('*');\n    \n    if (error) {\n      console.error('Error retrieving categories:', error);\n      return parsedIntent.components;\n    }\n    \n    // Map each component to closest category match\n    return parsedIntent.components.map(component => {\n      // Find best matching category\n      const matchedCategory = categories?.find(cat => \n        cat.name.toLowerCase().includes(component.category?.toLowerCase()) ||\n        component.category?.toLowerCase().includes(cat.name.toLowerCase())\n      );\n      \n      return {\n        ...component,\n        categoryId: matchedCategory?.id || null,\n        requiredSpecs: matchedCategory?.required_specs || {},\n        taxonomyMapped: !!matchedCategory\n      };\n    });\n  }\n  \n  /**\n   * Validate parsed intent for completeness\n   */\n  validateIntent(parsedIntent) {\n    const errors = [];\n    \n    if (!parsedIntent.projectType) {\n      errors.push('Missing project type');\n    }\n    \n    if (!parsedIntent.components || parsedIntent.components.length === 0) {\n      errors.push('No components identified');\n    }\n    \n    const essentialComponents = parsedIntent.components?.filter(c => c.priority === 'essential');\n    if (essentialComponents?.length === 0) {\n      errors.push('No essential components identified');\n    }\n    \n    return {\n      isValid: errors.length === 0,\n      errors\n    };\n  }\n}\n\nexport default IntentParser;\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 274, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/dbozz/bundleup-enhanced/app/api/parse-intent/route.js"],"sourcesContent":["// ============================================\n// API ROUTE: /api/parse-intent\n// Intent Parser - Decomposes user goals\n// ============================================\n\nimport { NextResponse } from 'next/server';\nimport IntentParser from '@/lib/intent-parser';\n\nexport async function POST(request) {\n  try {\n    const { userIntent, userId } = await request.json();\n    \n    if (!userIntent || typeof userIntent !== 'string') {\n      return NextResponse.json(\n        { error: 'User intent is required' },\n        { status: 400 }\n      );\n    }\n    \n    // Initialize Intent Parser\n    const parser = new IntentParser();\n    \n    // Parse the intent\n    const parsedIntent = await parser.parseIntent(\n      userIntent,\n      userId ? { userId } : null\n    );\n    \n    // Validate the parsed intent\n    const validation = parser.validateIntent(parsedIntent);\n    \n    if (!validation.isValid) {\n      return NextResponse.json({\n        success: false,\n        parsedIntent,\n        validation\n      }, { status: 200 });\n    }\n    \n    return NextResponse.json({\n      success: true,\n      parsedIntent,\n      validation\n    });\n    \n  } catch (error) {\n    console.error('Intent parsing error:', error);\n    \n    return NextResponse.json(\n      { \n        error: 'Failed to parse intent',\n        details: error.message \n      },\n      { status: 500 }\n    );\n  }\n}\n\nexport const runtime = 'nodejs';\nexport const maxDuration = 30;\n"],"names":[],"mappings":"AAAA,+CAA+C;AAC/C,+BAA+B;AAC/B,wCAAwC;AACxC,+CAA+C;;;;;;;;;AAE/C;AACA;;;AAEO,eAAe,KAAK,OAAO;IAChC,IAAI;QACF,MAAM,EAAE,UAAU,EAAE,MAAM,EAAE,GAAG,MAAM,QAAQ,IAAI;QAEjD,IAAI,CAAC,cAAc,OAAO,eAAe,UAAU;YACjD,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA0B,GACnC;gBAAE,QAAQ;YAAI;QAElB;QAEA,2BAA2B;QAC3B,MAAM,SAAS,IAAI,oIAAY;QAE/B,mBAAmB;QACnB,MAAM,eAAe,MAAM,OAAO,WAAW,CAC3C,YACA,SAAS;YAAE;QAAO,IAAI;QAGxB,6BAA6B;QAC7B,MAAM,aAAa,OAAO,cAAc,CAAC;QAEzC,IAAI,CAAC,WAAW,OAAO,EAAE;YACvB,OAAO,gJAAY,CAAC,IAAI,CAAC;gBACvB,SAAS;gBACT;gBACA;YACF,GAAG;gBAAE,QAAQ;YAAI;QACnB;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT;YACA;QACF;IAEF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,yBAAyB;QAEvC,OAAO,gJAAY,CAAC,IAAI,CACtB;YACE,OAAO;YACP,SAAS,MAAM,OAAO;QACxB,GACA;YAAE,QAAQ;QAAI;IAElB;AACF;AAEO,MAAM,UAAU;AAChB,MAAM,cAAc","debugId":null}}]
}